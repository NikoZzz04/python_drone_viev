<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cesium Drone Flight Demo</title>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html, body, #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #toggleCameraBtn {
            position: absolute;
            right: 20px;
            top: 20px;
            z-index: 9999;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-family: sans-serif;
            user-select: none;
        }
        #toggleCameraBtn:hover {
            background: rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div id="cesiumContainer"></div>
<div id="toggleCameraBtn">Toggle Camera</div>

<script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>

<script>
window.onload = function () {

    Cesium.Ion.defaultAccessToken = "CESIUM_ION_TOKEN";

    // Viewer
    const viewer = new Cesium.Viewer("cesiumContainer", {
        terrain: Cesium.Terrain.fromWorldTerrain(),
        timeline: false,
        animation: false,
        baseLayerPicker: false,
        geocoder: false,
        homeButton: false,
        navigationHelpButton: true,
        fullscreenButton: false
    });

    // Punkty trasy drona
    const punktyTrasy = [
    { lon: 21.181285, lat: 51.452653, h: 500 }, // 0°   – północ
    { lon: 21.196753, lat: 51.449346, h: 500 }, // 10°
    { lon: 21.211493, lat: 51.442294, h: 500 }, // 20°
    { lon: 21.224658, lat: 51.431977, h: 500 }, // 30°
    { lon: 21.235484, lat: 51.418942, h: 500 }, // 40°
    { lon: 21.243314, lat: 51.403791, h: 500 }, // 50°
    { lon: 21.247615, lat: 51.387160, h: 500 }, // 60°
    { lon: 21.248000, lat: 51.369700, h: 500 }, // 70°
    { lon: 21.244258, lat: 51.352050, h: 500 }, // 80°
    { lon: 21.236266, lat: 51.334806, h: 500 }, // 90°  – wschód
    { lon: 21.224089, lat: 51.318579, h: 500 }, // 100°
    { lon: 21.208426, lat: 51.304137, h: 500 }, // 110°
    { lon: 21.189948, lat: 51.291926, h: 500 }, // 120°
    { lon: 21.169426, lat: 51.282137, h: 500 }, // 130°
    { lon: 21.147426, lat: 51.275137, h: 500 }, // 140°
    { lon: 21.124948, lat: 51.271137, h: 500 }, // 150°
    { lon: 21.102853, lat: 51.270137, h: 500 }, // 160°
    { lon: 21.081853, lat: 51.272137, h: 500 }, // 170°
    { lon: 21.062426, lat: 51.277137, h: 500 }, // 180° – południe
    { lon: 21.045137, lat: 51.285137, h: 500 }, // 190°
    { lon: 21.030426, lat: 51.295926, h: 500 }, // 200°
    { lon: 21.018426, lat: 51.309137, h: 500 }, // 210°
    { lon: 21.009426, lat: 51.324137, h: 500 }, // 220°
    { lon: 21.003426, lat: 51.340426, h: 500 }, // 230°
    { lon: 21.000426, lat: 51.357137, h: 500 }, // 240°
    { lon: 21.000426, lat: 51.374137, h: 500 }, // 250°
    { lon: 21.003426, lat: 51.390426, h: 500 }, // 260°
    { lon: 21.009426, lat: 51.406137, h: 500 }, // 270° – zachód
    { lon: 21.018426, lat: 51.420426, h: 500 }, // 280°
    { lon: 21.030426, lat: 51.432137, h: 500 }, // 290°
    { lon: 21.045137, lat: 51.441137, h: 500 }, // 300°
    { lon: 21.062426, lat: 51.447137, h: 500 },   // 310°
    { lon: 21.081137, lat: 51.450137, h: 500 }, // 320°
    { lon: 21.101426, lat: 51.450137, h: 500 }, // 330°
    { lon: 21.121853, lat: 51.447137, h: 500 }, // 340°
    { lon: 21.141426, lat: 51.441137, h: 500 }, // 350°
    { lon: 21.159426, lat: 51.432137, h: 500 }, // 360°/0°
    { lon: 21.141426, lat: 51.441137, h: 500 },
    { lon: 21.121853, lat: 51.447137, h: 500 },
    { lon: 21.101426, lat: 51.450137, h: 500 },
    { lon: 21.081137, lat: 51.450137, h: 500 },
    { lon: 21.062426, lat: 51.447137, h: 500 },
    { lon: 21.045137, lat: 51.441137, h: 500 },
    { lon: 21.030426, lat: 51.432137, h: 500 },
    { lon: 21.018426, lat: 51.420426, h: 500 },
    { lon: 21.009426, lat: 51.406137, h: 500 },
    { lon: 21.003426, lat: 51.390426, h: 500 },
    { lon: 21.000426, lat: 51.374137, h: 500 },
    { lon: 21.000426, lat: 51.357137, h: 500 },
    { lon: 21.003426, lat: 51.340426, h: 500 },
    { lon: 21.009426, lat: 51.324137, h: 500 },
    { lon: 21.018426, lat: 51.309137, h: 500 },
    { lon: 21.030426, lat: 51.295926, h: 500 },
    { lon: 21.045137, lat: 51.285137, h: 500 },
    { lon: 21.062426, lat: 51.277137, h: 500 },
    { lon: 21.081853, lat: 51.272137, h: 500 },
    { lon: 21.102853, lat: 51.270137, h: 500 },
    { lon: 21.124948, lat: 51.271137, h: 500 },
    { lon: 21.147426, lat: 51.275137, h: 500 },
    { lon: 21.169426, lat: 51.282137, h: 500 },
    { lon: 21.189948, lat: 51.291926, h: 500 },
    { lon: 21.208426, lat: 51.304137, h: 500 },
    { lon: 21.224089, lat: 51.318579, h: 500 },
    { lon: 21.236266, lat: 51.334806, h: 500 },
    { lon: 21.244258, lat: 51.352050, h: 500 },
    { lon: 21.248000, lat: 51.369700, h: 500 },
    { lon: 21.247615, lat: 51.387160, h: 500 },
    { lon: 21.243314, lat: 51.403791, h: 500 },
    { lon: 21.235484, lat: 51.418942, h: 500 },
    { lon: 21.224658, lat: 51.431977, h: 500 },
    { lon: 21.211493, lat: 51.442294, h: 500 },
    { lon: 21.196753, lat: 51.449346, h: 500 },
    { lon: 21.181285, lat: 51.452653, h: 500 }  // zamknięcie pętli
];

    // Czas
    const totalSeconds = 180;
    const start = Cesium.JulianDate.now();
    const stop  = Cesium.JulianDate.addSeconds(start, totalSeconds, new Cesium.JulianDate());

    viewer.clock.startTime = start.clone();
    viewer.clock.stopTime  = stop.clone();
    viewer.clock.currentTime = start.clone();
    viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
    viewer.clock.multiplier = 1;
    viewer.clock.shouldAnimate = true;

    // Trajektoria
    const property = new Cesium.SampledPositionProperty();
    punktyTrasy.forEach((p, i) => {
        const time = Cesium.JulianDate.addSeconds(
            start,
            (i / (punktyTrasy.length - 1)) * totalSeconds,
            new Cesium.JulianDate()
        );
        const pos = Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.h);
        property.addSample(time, pos);
    });
    property.setInterpolationOptions({
        interpolationDegree: 2,
        interpolationAlgorithm: Cesium.HermitePolynomialApproximation
    });

    // Dron
    const dron = viewer.entities.add({
        availability: new Cesium.TimeIntervalCollection([ new Cesium.TimeInterval({ start, stop }) ]),
        position: property,
        orientation: new Cesium.VelocityOrientationProperty(property),
        /*model: {
            uri: "https://raw.githubusercontent.com/CesiumGS/cesium/main/Apps/SampleData/models/CesiumDrone/CesiumDrone.glb",
            minimumPixelSize: 80,
            maximumScale: 200,
            show: false
        },*/
        /*path: {
            width: 4,
            leadTime: 0,
            trailTime: totalSeconds,
            material: Cesium.Color.YELLOW,
            show: false
        }*/
    });
    let shouldLockCamera = true;
// ====================== DODAJESZ TYLKO TO ======================

const liczbaTowarzyszy = 30;
const maxOdlegloscOdToru = 5000;  // metrów (im więcej, tym dalej mogą być)
const minH = 350;
const maxH = 650;

for (let i = 0; i < liczbaTowarzyszy; i++) {
    // Losowa faza startowa + losowy promień i wysokość
    const fazaOffset = Math.random() * punktyTrasy.length;
    const skalaPromienia = 0.3 + Math.random() * 1.4; // 30–170% oryginalnego toru
    const wysokosc = minH + Math.random() * (maxH - minH);

    const property = new Cesium.SampledPositionProperty();

    punktyTrasy.forEach((punkt, idx) => {
        // Przesuwamy punkt radialnie od środka koła
        const dx = punkt.lon - 21.181285;
        const dy = punkt.lat - 51.407653;
        const nowyLon = 21.181285 + dx * skalaPromienia;
        const nowyLat = 51.407653 + dy * skalaPromienia;

        // przesunięcie w czasie (żeby nie startowały wszystkie z tego samego miejsca)
        const przesuniecieIdx = (idx + fazaOffset) % punktyTrasy.length;
        const czas = Cesium.JulianDate.addSeconds(
            viewer.clock.startTime,  // ← użyj tej samej zmiennej startowej co główny dron
            przesuniecieIdx * 8,     // co ~8 sekund nowy punkt (dostosuj prędkość)
            new Cesium.JulianDate()
        );

        const pozycja = Cesium.Cartesian3.fromDegrees(nowyLon, nowyLat, wysokosc);
        property.addSample(czas, pozycja);
    });

    property.setInterpolationOptions({
        interpolationDegree: 2,
        interpolationAlgorithm: Cesium.LagrangePolynomialApproximation
    });

    viewer.entities.add({
        position: property,
        orientation: new Cesium.VelocityOrientationProperty(property),
        model: {
            uri: "https://raw.githubusercontent.com/CesiumGS/cesium/main/Apps/SampleData/models/CesiumDrone/CesiumDrone.glb", // ten sam model co Twój dron
            minimumPixelSize: 48,
            maximumScale: 120,
            scale: 10 + Math.random() * 12,
            color: Cesium.C
        // opcjonalnie ścieżka
        },
        path: { width: 1.5, material: Cesium.Color.CYAN.withAlpha(0.6) }
    });
}
    // Ustaw przycisk zawsze po lewej stronie toolbara Cesium
    function positionToggleButton() {
        const toolbar = document.querySelector(".cesium-viewer-toolbar");
        const btn = document.getElementById("toggleCameraBtn");

        if (!toolbar || !btn) return;

        const toolbarRect = toolbar.getBoundingClientRect();

        // Pozycja przycisku:
        // "po lewej" = Move button so its RIGHT edge touches toolbar's LEFT edge
        btn.style.top = toolbarRect.top + "px";
        btn.style.right = (window.innerWidth - toolbarRect.left + 10) + "px";
    }

    // Po załadowaniu wszystkiego ustaw pozycję
    setTimeout(positionToggleButton, 200);

    // Reaguj na resize okna — Cesium zmienia layout
    window.addEventListener("resize", positionToggleButton);


    viewer.scene.postUpdate.addEventListener(function (scene, time) {
    const pos = dron.position.getValue(time);
    const quat = dron.orientation.getValue(time);

    if (!pos || !quat) return;
    const droneRotation = Cesium.Matrix3.fromQuaternion(quat);
    const hpr = Cesium.HeadingPitchRoll.fromQuaternion(quat);
    const direction = new Cesium.Cartesian3();
    const up        = new Cesium.Cartesian3();
    const right     = new Cesium.Cartesian3();

    Cesium.Matrix3.getColumn(droneRotation, 2, direction); // +Z drona = przód
    Cesium.Matrix3.getColumn(droneRotation, 1, up);        // +Y drona = góra
    Cesium.Matrix3.getColumn(droneRotation, 0, right);     // +X drona = prawo

    // === Najlepsza funkcja do wyciągnięcia prawdziwego roll ===
    function getRoll(dir, upVec, rightVec) {
    console.log({cccc: Cesium.Math.equalsEpsilon(Math.abs(dir.z), 1.0, Cesium.Math.EPSILON5)})
    return 0.0;
        if (Cesium.Math.equalsEpsilon(Math.abs(dir.z), 1.0, Cesium.Math.EPSILON5)) {
            return 0.0; // dron patrzy prosto w górę/dół – roll nieokreślony
        }
        return Math.atan2(-rightVec.z, upVec.z);
    }

    const roll = getRoll(direction, up, right);

    // Opcjonalnie: ogranicz roll do realistycznego zakresu (drony nie robią 360°)
    //const maxRoll = Cesium.Math.toRadians(40);
    //const clampedRoll = Cesium.Math.clamp(roll - Math.PI, -maxRoll, maxRoll); // -π..π → -60°..60°
    console.log(roll)
    // Ustawiamy kamerę – idealnie zsynchronizowaną z dronem
    viewer.camera.setView({
        destination: pos,
        orientation: {
            heading: hpr.heading+Math.PI, // +180° bo kamera patrzy do tyłu modelu
            pitch:   Cesium.Math.toRadians(-8),
            roll:    0.0  // tu jest prawdziwy, dynamiczny roll!
        }
    });

    viewer.camera.moveForward(2.5); // lekkie wysunięcie z modelu
});
}
</script>
</body>
</html>
