<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cesium Drone Flight Demo</title>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html, body, #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #toggleCameraBtn {
            position: absolute;
            right: 20px;
            top: 20px;
            z-index: 9999;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-family: sans-serif;
            user-select: none;
        }
        #toggleCameraBtn:hover {
            background: rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div id="cesiumContainer"></div>
<div id="toggleCameraBtn">Toggle Camera</div>

<script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>

<script>
window.onload = function () {

    Cesium.Ion.defaultAccessToken = "";

    // Viewer
    const viewer = new Cesium.Viewer("cesiumContainer", {
        terrain: Cesium.Terrain.fromWorldTerrain(),
        timeline: false,
        animation: false,
        baseLayerPicker: false,
        geocoder: false,
        homeButton: false,
        navigationHelpButton: true,
        fullscreenButton: false
    });

    // Punkty trasy drona
    const punktyTrasy = [
    // Środek koła: 51.407653 N, 21.181285 E. Promień: 5 km. Wysokość: 500 m.
    { lon: 21.181285, lat: 51.452653, h: 500 },
    { lon: 21.196658, lat: 51.449175, h: 500 },
    { lon: 21.211029, lat: 51.441865, h: 500 },
    { lon: 21.223842, lat: 51.430935, h: 500 },
    { lon: 21.234473, lat: 51.416867, h: 500 },
    { lon: 21.242337, lat: 51.400588, h: 500 },
    { lon: 21.246876, lat: 51.383161, h: 500 },
    { lon: 21.247599, lat: 51.365778, h: 500 },
    { lon: 21.244087, lat: 51.349342, h: 500 },
    { lon: 21.236306, lat: 51.334796, h: 500 },
    { lon: 21.224611, lat: 51.323214, h: 500 },
    { lon: 21.209632, lat: 51.315715, h: 500 },
    { lon: 21.192323, lat: 51.312984, h: 500 },
    { lon: 21.173887, lat: 51.315715, h: 500 },
    { lon: 21.156637, lat: 51.323214, h: 500 },
    { lon: 21.140942, lat: 51.334796, h: 500 },
    { lon: 21.127819, lat: 51.349342, h: 500 },
    { lon: 21.117769, lat: 51.365778, h: 500 },
    { lon: 21.111956, lat: 51.383161, h: 500 },
    { lon: 21.110756, lat: 51.400588, h: 500 },
    { lon: 21.113941, lat: 51.416867, h: 500 },
    { lon: 21.121805, lat: 51.430935, h: 500 },
    { lon: 21.133276, lat: 51.441865, h: 500 },
    { lon: 21.146950, lat: 51.449175, h: 500 },
    { lon: 21.162323, lat: 51.452653, h: 500 },
    { lon: 21.181285, lat: 51.452653, h: 500 }, // Pełny okrąg (powrót do pozycji startowej)
    { lon: 21.196658, lat: 51.449175, h: 500 },
    { lon: 21.211029, lat: 51.441865, h: 500 },
    { lon: 21.223842, lat: 51.430935, h: 500 },
    { lon: 21.234473, lat: 51.416867, h: 500 },
    { lon: 21.242337, lat: 51.400588, h: 500 },
    { lon: 21.246876, lat: 51.383161, h: 500 },
    { lon: 21.247599, lat: 51.365778, h: 500 },
    { lon: 21.244087, lat: 51.349342, h: 500 },
    { lon: 21.236306, lat: 51.334796, h: 500 },
    { lon: 21.224611, lat: 51.323214, h: 500 },
    { lon: 21.209632, lat: 51.315715, h: 500 } // Ostatni punkt (bliski startowemu)
];

    // Czas
    const totalSeconds = 180;
    const start = Cesium.JulianDate.now();
    const stop  = Cesium.JulianDate.addSeconds(start, totalSeconds, new Cesium.JulianDate());

    viewer.clock.startTime = start.clone();
    viewer.clock.stopTime  = stop.clone();
    viewer.clock.currentTime = start.clone();
    viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
    viewer.clock.multiplier = 1;
    viewer.clock.shouldAnimate = true;

    // Trajektoria
    const property = new Cesium.SampledPositionProperty();
    punktyTrasy.forEach((p, i) => {
        const time = Cesium.JulianDate.addSeconds(
            start,
            (i / (punktyTrasy.length - 1)) * totalSeconds,
            new Cesium.JulianDate()
        );
        const pos = Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.h);
        property.addSample(time, pos);
    });
    property.setInterpolationOptions({
        interpolationDegree: 2,
        interpolationAlgorithm: Cesium.HermitePolynomialApproximation
    });

    // Dron
    const dron = viewer.entities.add({
        availability: new Cesium.TimeIntervalCollection([ new Cesium.TimeInterval({ start, stop }) ]),
        position: property,
        orientation: new Cesium.VelocityOrientationProperty(property),
        /*model: {
            uri: "https://raw.githubusercontent.com/CesiumGS/cesium/main/Apps/SampleData/models/CesiumDrone/CesiumDrone.glb",
            minimumPixelSize: 80,
            maximumScale: 200,
            show: false
        },*/
        /*path: {
            width: 4,
            leadTime: 0,
            trailTime: totalSeconds,
            material: Cesium.Color.YELLOW,
            show: false
        }*/
    });
    let shouldLockCamera = true;
// ====================== DODAJESZ TYLKO TO ======================

const liczbaTowarzyszy = 30;
const maxOdlegloscOdToru = 5000;  // metrów (im więcej, tym dalej mogą być)
const minH = 350;
const maxH = 650;

for (let i = 0; i < liczbaTowarzyszy; i++) {
    // Losowa faza startowa + losowy promień i wysokość
    const fazaOffset = Math.random() * punktyTrasy.length;
    const skalaPromienia = 0.3 + Math.random() * 1.4; // 30–170% oryginalnego toru
    const wysokosc = minH + Math.random() * (maxH - minH);

    const property = new Cesium.SampledPositionProperty();

    punktyTrasy.forEach((punkt, idx) => {
        // Przesuwamy punkt radialnie od środka koła
        const dx = punkt.lon - 21.181285;
        const dy = punkt.lat - 51.407653;
        const nowyLon = 21.181285 + dx * skalaPromienia;
        const nowyLat = 51.407653 + dy * skalaPromienia;

        // przesunięcie w czasie (żeby nie startowały wszystkie z tego samego miejsca)
        const przesuniecieIdx = (idx + fazaOffset) % punktyTrasy.length;
        const czas = Cesium.JulianDate.addSeconds(
            viewer.clock.startTime,  // ← użyj tej samej zmiennej startowej co główny dron
            przesuniecieIdx * 8,     // co ~8 sekund nowy punkt (dostosuj prędkość)
            new Cesium.JulianDate()
        );

        const pozycja = Cesium.Cartesian3.fromDegrees(nowyLon, nowyLat, wysokosc);
        property.addSample(czas, pozycja);
    });

    property.setInterpolationOptions({
        interpolationDegree: 2,
        interpolationAlgorithm: Cesium.LagrangePolynomialApproximation
    });

    viewer.entities.add({
        position: property,
        orientation: new Cesium.VelocityOrientationProperty(property),
        model: {
            uri: "https://raw.githubusercontent.com/CesiumGS/cesium/main/Apps/SampleData/models/CesiumDrone/CesiumDrone.glb", // ten sam model co Twój dron
            minimumPixelSize: 48,
            maximumScale: 120,
            scale: 10 + Math.random() * 12,
            color: Cesium.C
        // opcjonalnie ścieżka
        },
        path: { width: 1.5, material: Cesium.Color.CYAN.withAlpha(0.6) }
    });
}
    // Ustaw przycisk zawsze po lewej stronie toolbara Cesium
    function positionToggleButton() {
        const toolbar = document.querySelector(".cesium-viewer-toolbar");
        const btn = document.getElementById("toggleCameraBtn");

        if (!toolbar || !btn) return;

        const toolbarRect = toolbar.getBoundingClientRect();

        // Pozycja przycisku:
        // "po lewej" = Move button so its RIGHT edge touches toolbar's LEFT edge
        btn.style.top = toolbarRect.top + "px";
        btn.style.right = (window.innerWidth - toolbarRect.left + 10) + "px";
    }

    // Po załadowaniu wszystkiego ustaw pozycję
    setTimeout(positionToggleButton, 200);

    // Reaguj na resize okna — Cesium zmienia layout
    window.addEventListener("resize", positionToggleButton);


    viewer.scene.postUpdate.addEventListener(function (scene, time) {
    const pos = dron.position.getValue(time);
    const quat = dron.orientation.getValue(time);

    if (pos && quat) {
    const hpr = Cesium.HeadingPitchRoll.fromQuaternion(quat);
    const cameraRoll = hpr.roll * 0.75;
    viewer.camera.setView({
        destination: pos,
        orientation: {
            heading: hpr.heading + Math.PI,
            pitch:   Cesium.Math.toRadians(-10),
            roll    :-cameraRoll
        }
    });

        // Lekko do przodu, żeby nie być w środku modelu
        viewer.camera.moveForward(2);
    }
});
}
</script>
</body>
</html>